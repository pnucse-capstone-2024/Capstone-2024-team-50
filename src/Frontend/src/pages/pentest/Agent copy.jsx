import React, {useContext} from 'react';
import { UserContext } from '../../core/user';



import { useNavigate } from 'react-router-dom';

import { Typography, Button, CircularProgress } from '@mui/material'

import AttackMap from './module/AttackMap';
import AgentSelect from './module/AgentSelect';
import { fetchGetAttackTactics, fetchGetAttackTechniques, fetchTestWifiDoS } from '../../services/AttackMapServices';

const TACTICID = [
    'TA0043',
    'TA0042',
    'TA0001',
    'TA0002',
    'TA0003',
    'TA0004',
    'TA0005',
    'TA0006',
    'TA0007',
    'TA0008',
    'TA0009',
    'TA0011',
    'TA0010',
    'TA0040'
]

const status = [
    'init',
    'success',
    'fail',
]


const Agent = ({view}) => {
    const [hostname, setHostname] = React.useState([]);
    const [finishAttack, setFinishAttack] = React.useState(false);
    const navigate = useNavigate();
    const [tactics, setTactics] = React.useState([]);
    const [groupedTechniques, setGroupedTechniques] = React.useState({});
    const [loading, setLoading] = React.useState(false);
    const { userState } = useContext(UserContext);

    const handleAttack = async () => {
        setLoading(true);
    
        const processTechniques = async (tacticid, techniques) => {
            for (let techIndex = 0; techIndex < techniques.length; techIndex++) {
                const technique = techniques[techIndex];
                console.log('Processing technique:', technique);
                // technique.tid가 tid
                // attack에 tid가 있음
                // command에 attack_id와 platform가 있음
                // 그러면 사용자느 tid랑 uid를 보내주면 돼
                // 백엔드에서는 tid로 attack_id를 찾아서 platform을 찾아서 command를 실행시키면 됨
                // 해보자
                
                // 기술의 상태를 'loading'으로 설정
                setGroupedTechniques((prev) => {
                    const updatedTechniques = prev[tacticid].map((t) => {
                        if (t.tid === technique.tid) {
                            return { ...t, status: 'loading' };
                        }
                        return t;
                    });
                    return {
                        ...prev,
                        [tacticid]: updatedTechniques,
                    };
                });
    
                await new Promise((resolve) => {
                    setTimeout(() => {
                        setGroupedTechniques((prev) => {
                            const updatedTechniques = prev[tacticid].map((t) => {
                                if (t.tid === technique.tid) {
                                    // 10% 확률로 실패
                                    const status = Math.random() <= 0.1 ? 'fail' : 'success';
                                    return { ...t, status };
                                }
                                return t;
                            });
                            return {
                                ...prev,
                                [tacticid]: updatedTechniques,
                            };
                        });
                        resolve();
                    }, Math.random() * 1000); // 기술당 지연 시간
                });
            }
        };
    
        const processTactics = async () => {
            for (let tacticIndex = 0; tacticIndex < TACTICID.length; tacticIndex++) {
                const tacticid = TACTICID[tacticIndex];
                await new Promise((resolve) => {
                    setTimeout(async () => {
                        const techniques = groupedTechniques[tacticid];
                        if (techniques) {
                            await processTechniques(tacticid, techniques);
                        }
                        resolve();
                    }, 100); // 전술당 지연 시간
                });
            }
        };
    
        await processTactics();
        fetchTestWifiDoS(userState.uid);
        setFinishAttack(true);
        setLoading(false);
    };
    
    React.useEffect(() => {
        // Fetch tactics
        fetchGetAttackTactics().then((response) => {
            if (response.status === 200) {
                response.json().then((data) => {
                    setTactics(data);
                });
            }
        });

        // Fetch techniques
        fetchGetAttackTechniques().then((response) => {
            if (response.status === 200) {
                response.json().then((data) => {
                    // Group techniques by their taid
                    const grouped = data.reduce((acc, technique) => {
                        const taid = technique.taid;
                        if (!acc[taid]) {
                            acc[taid] = [];
                        }
                        // acc[taid].push(technique);
                        acc[taid].push({ ...technique, status: 'init' });
                        return acc;
                    }, {});
                    setGroupedTechniques(grouped);
                    console.log('s',grouped);
                });
            }
        });
    }, []);

    return (
        <div>
            {!view && 
            <>
            <Typography variant='h4' sx={{fontWeight:'bold'}}> MITRE ATT&CK </Typography>
            <div className='flex flex-row' style={{display:'flex', alignItems:'center', gap: '16px'}}>
                <AgentSelect hostname={hostname} setHostname={setHostname} loading={loading}/>
                <Button variant='contained' disabled={hostname == "" || loading ? true : false} sx={{height:48, mt:2}} onClick={handleAttack}>
                    {loading ? <CircularProgress/> : 'Attack'}
                </Button>
                <Button
                    disabled={!finishAttack}
                    variant='contained'
                    sx={{height:48, mt:2}}
                    onClick={()=>{navigate('/pentest/result')}}
                >
                    GoTo Result
                </Button>
                <br />
            </div>
            </>
            }
            <br />
            <AttackMap tactics={tactics} groupedTechniques={groupedTechniques}/>
            
        </div>
    )
}

export default Agent;